function [t, r, v, stats] = Encke(solver, perturbation, solver_order, tspan, rt0, vt0, muC, options)

    % Please report bugs and inquiries to:
    %
    % Name       : Rody P.S. Oldenhuis
    % E-mail     : oldenhuis@gmail.com    (personal)
    %              oldenhuis@luxspace.lu  (professional)
    % Affiliation: LuxSpace sarl
    % Licence    : BSD


    % If you find this work useful, please consider a donation:
    % https://www.paypal.me/RodyO/3.5


% Following Battin, pages 448-449

    %% Initialize

    % Check I/O argument
    error(nargchk   (7, 8, nargin,  'struct'));
    error(nargoutchk(0, 4, nargout, 'struct'));

    assert(isa(solver, 'function_handle'), ...
          [mfilename ':ioarg_error'],...
          'Argument ''solver'' must be a valid function handle.');

    assert(isa(perturbation, 'function_handle'), ...
          [mfilename ':ioarg_error'],...
          'Argument ''perturbation'' must be a valid function handle.');

    assert(isnumeric(solver_order) && isscalar(solver_order) && any(solver_order == [1 2]),...
           [mfilename ':unsupported_solver_order'],...
           'Solver order must be equal to 1 or 2.');

    assert(isnumeric(tspan) && isvector(tspan) && numel(tspan) >= 2 && ...
           all(isfinite(tspan)) && all(isreal(tspan)) && ...
           issorted(tspan) && numel(tspan) == numel(unique(tspan)), ...
           [mfilename ':ioarg_error'],...
           'The time span vector (''tspan'') must be given as real, sorted values.');

    assert(isnumeric(rt0) && isvector(rt0) && numel(rt0) == 3 && all(isreal(rt0)) && all(isfinite(rt0)) && ...
           isnumeric(vt0) && isvector(vt0) && numel(vt0) == 3 && all(isreal(vt0)) && all(isfinite(vt0)),...
           [mfilename ':ioarg_error'],...
           'The initial position and velocity (''rt0'', ''vt0'') must both be real 3-element vectors.');

    assert(isnumeric(muC) && isscalar(muC) && muC > 0 && isreal(muC),...
           [mfilename ':ioarg_error'],...
           ['The standard gravitational parameter of the central body (''muC'') must be givan ',...
           'as a real positive scalar.']);

    % Initialize constants
    stats.rectifications = 0;
    stats.function_evaluations = 1; % NOTE: one eval is done to check the user-provided function

    % Initialize options
    if nargin < 6 || isempty(options)
        options = odeset; end

    assert(isstruct(options),...
           [mfilename ':invalid_options'],...
           'Argument ''options'' must be a structure generated by odeset().');

    if isempty(solver)
        % Defaults to  best integrator in standard MATLAB
        solver       = @ode113;
        solver_order = 1;
    end

    % Make sure the disturbing acceleration function works
    try
        if solver_order==1
            [~] = perturbation(tspan(1),rt0,vt0);
        else
            [~] = perturbation(tspan(1),rt0);
        end

    catch ME
        ME2 = MException([mfilename ':perturbation_failure'],...
                         'Failed to evaluate disturbing acceleration function for initial values.');
        throw(addCause(ME,ME2));
    end






    tosc = tspan(1);
    rosc = rt0;
    vosc = vt0;

    t_out = tosc;
    r_out = rosc;
    v_out = vosc;
    
    
    prev_delta = zeros(3,1);
    prev_deltadot = zeros(3,1);
    


    % Set/get defaults. Make sure the rectification check is carried
    % out at each integration step
    % NOTE: An output function is used to detect an event. Although an
    % EvenFcn would seem better suited, in this case, we're not
    % interested in *exactly* where the rectification should take place
    % (standard behavior in almost all ODE solvers), but rather, whether
    % it makes sense to do it in the next step. Therefore, to save on
    % function evaluations, the terminal property of the OutputFunction is
    % used, which makes sure the condition is only checked *once* per
    % iteration.
    solver_options = odeset(options, ...                            
                            'AbsTol'   , odeget(options, 'AbsTol', 1e-8),...
                            'RelTol'   , odeget(options, 'RelTol', 1e-8),...
                            'OutputFcn', @(varargin) check_rectify(varargin{:}) || ...
                                                     feval(odeget(options, 'OutputFcn', @(varargin)false), varargin{:})...
    );






    % The 2 solver types have 2 different calls
    if solver_order == 1
        D = solver(@de1, ...
                   tspan, ...
                   zeros(6,1),...
                   solver_options);
    else
        D = solver(@de2, ...
                   tspan, ...
                   zeros(3,1),...
                   zeros(3,1),...
                   solver_options);
    end

    stats.function_evaluations = D.stats.nfevals;
    
    t = t_out;
    r = r_out.';
    v = v_out.';




    function terminate = check_rectify(t, y, flag)
        
        % Output function halts integration
        terminate = false;

        % empty flag == after successful step
        if isempty(flag)

            % Rename input for clarity
            t_new        = t(end);
            delta_new    = y(1:3,end);
            deltadot_new = y(4:6,end);
            
            delta_real    = delta_new    - prev_delta;
            deltadot_real = deltadot_new - prev_deltadot;

            % Progress osculating orbit
            [rosc, vosc] = advance_osculating_orbit(rosc,...
                                                    vosc,...
                                                    t_new - tosc,...
                                                    muC);

            % (rectification)
            tosc = t_new;
            rosc = rosc + delta_real;
            vosc = vosc + deltadot_real;

            % Assign new solution to function output
            t_out = [t_out;  t_new];
            r_out = [r_out   rosc ];
            v_out = [v_out   vosc ];

            % Keep track of solver's solutions
            prev_delta    = delta_new;
            prev_deltadot = deltadot_new;

        end

    end


    % Compute first derivative of
    %
    %    y(t) = [
    %       delta(t)     = r(t) - rosc(t)
    %       delta_dot(t) = v(t) - vosc(t)
    %    ]
    %
    % This DE should be used if the disturbing acceleration depends on the
    % velocity, or if the solver is designed to solve systems of the type
    %
    %       dy/dt = f(t,y)
    % s.t.  y(t0) = y0
    %
    function dydt = de1(t, y)

        delta     = y(1:3);
        delta_dot = y(4:6);
        
        delta_real     = delta     - prev_delta;
        delta_dot_real = delta_dot - prev_deltadot;

        [rosc_t, vosc_t] = advance_osculating_orbit(rosc, vosc, t - tosc, muC);

        r_t  = delta_real     + rosc_t;
        v_t  = delta_dot_real + vosc_t;

        q_t  = delta_real.' * (delta_real - 2*r_t) / (r_t.' * r_t);
        fq   = 1 - (1 + q_t)^(3/2);

        a_main    = muC/norm(rosc_t)^3 * (fq*r_t - delta_real);
        a_perturb = perturbation(t, r_t, v_t);
        a_total   = a_main + a_perturb;

        % Generate output
        dydt = [delta_dot_real  % d (delta)/dt
                a_total];  % d²(delta)/dt²
            
    end






end




%{


    % Main loop:
    % - Let solver integrate until rectification is needed
    % - Break off integration and collect data
    % - Apply recitifcation
    % - Repeat from the start, until the final time is reached.
    while ~done

        t0 = tspan(1);

        % The 2 sovler types have 2 different calls
        if solver_order == 1
            D = solver(@(t,y) de1(t,y, perturbation,t0,rt0,vt0,muC), ...
                       tspan, ...
                       zeros(6,1),...
                       solver_options);

            delta    = D.y(1:3,:).';
            deltadot = D.y(4:6,:).';

        else
            D = solver(@(t,y) de2(t,y, perturbation,t0,rt0,vt0,muC), ...
                       tspan, ...
                       zeros(3,1),...
                       zeros(3,1),...
                       solver_options);

            delta    = D.y;
            deltadot = D.yp;

        end

        tslice = D.x(:);
        stats.function_evaluations = stats.function_evaluations + D.stats.nfevals;

        % Save values for next iteration
        hinitial = tslice(end-1) - tslice(end-2);
        tspan    = [tslice(end) tspan(end)];
        done     = tslice(end)==tspan(end);

        % We can in all likelihood keep using the step size from the
        % previous integration
        solver_options = odeset(solver_options,...
                                'InitialStep', hinitial);

        % Insert data into output arrays
        [rosc, vosc] = check_rectify();
        t = [t;  tslice(1:end-~done)];                                   %#ok<AGROW>
        r = [r   [rt0 rosc(:,1:end-~done)] + delta(1:end-~done,:).'   ]; %#ok<AGROW>
        v = [v   [vt0 vosc(:,1:end-~done)] + deltadot(1:end-~done,:).']; %#ok<AGROW>

        % Apply rectification
        rt0 = rosc(:,end) + delta(end,:).';
        vt0 = vosc(:,end) + deltadot(end,:).';
        stats.rectifications = stats.rectifications + ~done;

    end

    % Transpose to have dims of t, r and v all agree
    r = r.';
    v = v.';

end


% Little wrapper function; checks if rectification is needed
function varargout = check_rectify(solver_order, varargin)

    persistent rosc vosc
    if nargin == 0
        varargout{1} = rosc;
        varargout{2} = vosc;
        return;
    end

    terminate = false;
    flag = varargin{end};
    if isempty(flag)
        if solver_order == 1
            [terminate, rosc(:,end+1), vosc(:,end+1)] = de1();
        else
            [terminate, rosc(:,end+1), vosc(:,end+1)] = de2();
        end

    elseif strcmp(flag, 'init')
        rosc = [];
        vosc = [];
    end

    varargout{1} = terminate;

end


% Compute first derivative of
%
%    y(t) = [
%       delta(t)     = r(t) - rosc(t)
%       delta_dot(t) = v(t) - vosc(t)
%    ]
%
% This DE should be used if the disturbing acceleration depends on the
% velocity, or if the solver is designed to solve systems of the type
%
%       dy/dt = f(t,y)
% s.t.  y(t0) = y0
%
function varargout = de1(t,y, perturbation, t0, rt0,vt0, muC)

    persistent a_main a_perturb rosc vosc
    if nargin==0
        % Condition to trigger rectification
        varargout{1} = norm(a_main) > 0.9*norm(a_perturb);
        % Osculating orbit data
        varargout{2} = rosc;
        varargout{3} = vosc;
        return;
    end

    delta     = y(1:3);
    delta_dot = y(4:6);

    [rosc, vosc] = advance_osculating_orbit(rt0,vt0, t-t0, muC);
    r  = delta + rosc;
    v  = delta_dot + vosc;
    q  = delta'*(delta-2*r) / (r'*r);
    fq = 1-(1+q)^(3/2);

    a_main    = muC/norm(rosc)^3 * (fq*r - delta);
    a_perturb = perturbation(t,r,v);
    a_total   = a_main + a_perturb;

    % Generate output
    varargout{1} = [
        delta_dot  % d (delta)/dt
        a_total    % d²(delta)/dt²
    ];

end


% Compute second derivative of
%
%    delta(t) = r(t) - rosc(t)
%
% This DE should be used if the disturbing acceleration is independent of
% the velocity. If this is the case, the solver must ba designed to solve
% systems of type
%
%     d²y/dt² = f(t,y)
% s.t.  y(t0) = y0
%       dy/dt = v0
%
function varargout = de2(t, delta, perturbation, t0, rt0,vt0, muC)

    % Condition to trigger rectification
    persistent a_main a_perturb rosc vosc
    if nargin==0
       % Condition to trigger rectification
        varargout{1} = norm(a_main) > 0.9*norm(a_perturb);
        % Osculating orbit data
        varargout{2} = rosc;
        varargout{3} = vosc;
        return;
    end

    [rosc,vosc] = advance_osculating_orbit(rt0,vt0, t-t0, muC);
    r  = delta + rosc;
    q  = delta'*(delta-2*r) / (r'*r);
    fq = 1-(1+q)^(3/2);

    % Generate output
    a_main       = muC/norm(rosc)^3 * (fq*r - delta);
    a_perturb    = perturbation(t,r);
    varargout{1} = a_main + a_perturb;

end

%}

% Compute position & velocity after a certain time step
%
% References:
% [1] S.W. Shepperd, "Universal Keplerian State Transition Matrix".
% Celestial Mechanics 35(1985) pp. 129--144, DOI: 0008-8714/85.15
function [rosc, vosc] = advance_osculating_orbit(rt, vt, dt, muC)
% %#eml
% eml.extrinsic('warning', 'error');

    % Quick exit for trivial case
    rosc = rt;
    vosc = vt;
    if (dt == 0)
        return; end

    % Intitialize
    maxiters = 50;
    r1   = rt(:).';
    v1   = vt(:).';
    nu0  = r1*v1.';
    r1m  = norm(r1);
    beta = 2*muC/r1m - v1*v1.';
    ulim = 1/sqrt(abs(beta));

    % Take care of period effects
    DeltaU = 0;
    if (beta > 0)
        P = 2*pi*muC*beta^(-3/2);
        n = floor((dt + P/2 - 2*nu0/beta)/P);
        DeltaU = 2*pi*n*beta^(-5/2);
    end

    % Loop until convergence of the time step
    iter   = 0;      t = 0;   regulafalsi_count = 0;
    deltaT = t-dt;   u = 0;
    while abs(deltaT) > 1e2*max(eps([t dt])) % accuracy in seconds
        iter = iter + 1;                     % (two last digits are allowed to differ)

        % Compute q
        % NOTE: [q] may not exceed 1/2. In principle, this will never
        % occur, but the iterative nature of the procedure can bring
        % it above 1/2 for some iterations.
        bu = beta*u*u;
        q  = bu/(1 + bu);

        % Escape clause;
        % The value for [q] will almost always stabilize to a value less
        % than 1/2 after a few iterations, but NOT always.
        if (iter > maxiters)
            if (q > 0.5)
                error(...
                    'lagrange_coefs:q_unstable',...
                    'Could not find solution in %d iterations.', maxiters);
            else
                warning(...
                    'lagrange_coefs:time_accuracy_not_met',...
                    ['Could not find Lagrange coefficients with time accuracy better ',...
                    'than %e. Assuming convergence...'], 1e2*max(eps([t dt])));
                break
            end
        end

        % Evaluate continued fraction
        if q < 1 % convergence
            A =  1;   B = 1;   G = 1;   n = 0;
            k = -9;   d = 15;  l = 3;   Gprev = inf;
            while abs(G-Gprev) > 1e4*max(eps([G Gprev]))
                k = -k;                 l = l + 2;
                d = d + 4*l;            n = n + (1+k)*l;
                A = d/(d - n*A*q);      B = (A-1)*B;
                Gprev = G;              G = G + B;
            end % continued fraction evaluation

        else
            error(...
                'lagrange_coefs:continued_fraction_diverges',...
                'Continued fraction diverges for q = %e', q);
        end

        % Kepler iteration
        U0w2   = 1 - 2*q;
        U1w2   = 2*(1-q)*u;
        U      = 16/15*U1w2^5*G + DeltaU;
        U0     = 2*U0w2^2-1;
        U1     = 2*U0w2*U1w2;
        U2     = 2*U1w2^2;
        U3     = beta*U + U1*U2/3;
        r      = r1m*U0 + nu0*U1 + muC*U2;
        t      = r1m*U1 + nu0*U2 + muC*U3;
        deltaT = t - dt;
        uPrev  = u;

        % Newton-Raphson method works most of the time, but is
        % not too stable; Halley's method is much better:
        % u = u - deltaT/4/(1-q)/r;
        u = u - deltaT/((1-q)*(4*r + deltaT*beta*u));

        % But that too might fail. If that is the case, try to rescue
        % by making a single Regula-Falsi step
        if abs(u) > ulim
            u = (uPrev - sign(deltaT)*ulim)/2;
            regulafalsi_count = regulafalsi_count + 1;
            if regulafalsi_count > maxiters/2
                error(...
                    'lagrange_coefs:u_unstable',...
                    'Could not locate zero of deltaT(u).');
            end
        end

    end % time loop

    if iter ~= 0
        % Produce Lagrange coefficients
        f = 1 - muC/r1m*U2;     F = -muC*U1/r/r1m;
        g = r1m*U1 + nu0*U2;    G = 1 - muC/r*U2;

        % and the new orbital position and velocity
        rosc = f*rt + g*vt;
        vosc = F*rt + G*vt;
    end

end

